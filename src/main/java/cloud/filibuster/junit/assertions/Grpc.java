package cloud.filibuster.junit.assertions;

import cloud.filibuster.exceptions.filibuster.FilibusterRuntimeException;
import cloud.filibuster.exceptions.filibuster.FilibusterUnsupportedAPIException;
import cloud.filibuster.junit.server.core.FilibusterCore;
import io.grpc.StatusException;
import io.grpc.StatusRuntimeException;
import org.junit.jupiter.api.function.ThrowingConsumer;

import static cloud.filibuster.instrumentation.helpers.Property.getServerBackendCanInvokeDirectlyProperty;
import static cloud.filibuster.junit.Assertions.wasFaultInjected;

public class Grpc {
    /**
     * Execute a test and catch GRPC exceptions.
     *
     * @param block block to execute containing test.
     * @param catchBlock assertion block triggered, if and only if, GRPC exception is thrown
     * @throws Throwable rethrown exceptions generated by either the @{block} or @{catchBlock}
     */
    public static void tryGrpcAndCatchGrpcExceptions(
            Runnable block,
            ThrowingConsumer<Throwable> catchBlock
    ) throws Throwable {
        // Increment the scope counter for entry into this block.
        incrementTestScopeCounter();

        try {
            // Run the provided test block.
            block.run();
        } catch (Throwable t) {

            if (!wasFaultInjected()) {
                // If a fault wasn't injected -- which returns false always when Filibuster is disabled --
                // then, rethrow whatever exception occurred.
                //
                // It's unclear why the compiler analysis can't determine that this function throws a Throwable,
                // since the default implementation of this function returns true.
                //
                throw t;
            }

            // Fault injected.

            // This warning is not true, ignore.
            if (t instanceof StatusException || t instanceof StatusRuntimeException) {
                // If a GRPC exception was thrown, trigger the catch block.
                catchBlock.accept(t);
            } else {
                // Otherwise, it might be a normal assertion failure.
                // If so, rethrow.
                throw t;
            }
        }
    }

    /**
     * Execute the following block without faults.
     * <p>
     * Assumes that the block is executed synchronously -- use of this inside of concurrency primitives without
     * explicit synchronization may render this function unable to prevent faults from being injected.
     *
     * @param block block to execute synchronously.
     */
    public static void executeGrpcWithoutFaults(Runnable block) {
        incrementTestScopeCounter();
        disableFaultInjection();
        block.run();
        enableFaultInjection();
    }

    // Increment the fault-scope counter, which is just a counter of how many assertion blocks
    // we have entered via the test.
    private static void incrementTestScopeCounter() {
        if (getServerBackendCanInvokeDirectlyProperty()) {
            if (FilibusterCore.hasCurrentInstance()) {
                FilibusterCore.getCurrentInstance().incrementTestScopeCounter();
            } else {
                throw new FilibusterUnsupportedAPIException("Unable to execute test; @TestWithFilibuster was used but no instance of Core could be found.");
            }
        } else {
            throw new FilibusterUnsupportedAPIException("Unable to execute test; Filibuster must be enabled using @TestWithFilibuster and a supported backend must be supplied.");
        }
    }

    // Turn off fault injection until explicitly re-enabled.
    private static void disableFaultInjection() {
        if (getServerBackendCanInvokeDirectlyProperty()) {
            if (FilibusterCore.hasCurrentInstance()) {
                FilibusterCore.getCurrentInstance().disableFaultInjection();
            } else {
                throw new FilibusterUnsupportedAPIException("Unable to execute test; @TestWithFilibuster was used but no instance of Core could be found.");
            }
        } else {
            throw new FilibusterUnsupportedAPIException("Unable to execute test; Filibuster must be enabled using @TestWithFilibuster and a supported backend must be supplied.");
        }
    }

    // Turn on fault injection until explicitly disabled.
    private static void enableFaultInjection() {
        if (getServerBackendCanInvokeDirectlyProperty()) {
            if (FilibusterCore.hasCurrentInstance()) {
                FilibusterCore.getCurrentInstance().enableFaultInjection();
            } else {
                throw new FilibusterUnsupportedAPIException("Unable to execute test; @TestWithFilibuster was used but no instance of Core could be found.");
            }
        } else {
            throw new FilibusterUnsupportedAPIException("Unable to execute test; Filibuster must be enabled using @TestWithFilibuster and a supported backend must be supplied.");
        }
    }

    /**
     * Determine if a fault was injected during the current test execution.
     *
     * Only works if the target service is instrumented using a server instrumentor and reports its name.
     *
     * @param serviceName service name, as reported by a server instrumentor.
     * @return was fault injected
     */
    public static boolean wasFaultInjectedOnService(String serviceName) {
        if (serviceName != null) {  // TODO check serviceName format is actual grpc
            if (getServerBackendCanInvokeDirectlyProperty()) {
                if (FilibusterCore.hasCurrentInstance()) {
                    return FilibusterCore.getCurrentInstance().wasFaultInjectedOnService(serviceName);
                } else {
                    return false;
                }
            } else {
                return wasFaultInjected("/filibuster/fault-injected/service/" + serviceName);
            }
        } else {
            throw new FilibusterRuntimeException("Service name does not indicate a GRPC service.");
        }
    }
}
